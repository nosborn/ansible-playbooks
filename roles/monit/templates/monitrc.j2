set daemon 60 with start delay 60
set idfile /var/db/monit.id
set logfile syslog
set statefile /var/db/monit.state

set alert nick@{{ global_domain }} not on { instance, action }
set mailserver localhost
set mail-format {
  subject: monit alert -- $EVENT $SERVICE
  message: $EVENT Service $SERVICE

        Date: $DATE
      Action: $ACTION
        Host: $HOST
 Description: $DESCRIPTION
}

{% if lan_ipv6 is defined %}
set httpd port 2812 address "{{ lan_ipv6|ipaddr('address') }}"
{% else %}
set httpd port 2812 address "{{ lan_ipv4|ipaddr('address') }}"
{% endif %}
    signature disable
    allow {{ monit_username }}:{{ monit_password }} read-only

###############################################################################
## Services
###############################################################################

check process avahi-daemon with pidfile /var/run/avahi-daemon/pid
  start program = "/usr/sbin/rcctl start avahi_daemon"
  stop program = "/usr/sbin/rcctl stop avahi_daemon"
  if does not exist for 2 cycles then restart
  if failed uid _avahi then alert
  if failed euid _avahi then alert
  if failed gid nobody then alert
  depends on LAN
{% if c_icap_pid_file is defined %}

#check process c-icap with pidfile {{ c_icap_pid_file }}
#  start program = "/usr/sbin/rcctl start c_icap"
#  stop program = "/usr/sbin/rcctl stop c_icap"
#  if does not exist for 2 cycles then restart
{% endif %}

check process dhcpcd with pidfile /var/run/dhcpcd.pid
  start program = "/usr/sbin/rcctl start dhcpcd"
  stop program = "/usr/sbin/rcctl stop dhcpcd"
  if does not exist for 2 cycles then restart
  depends on WAN

check process dhcpd matching "^/usr/sbin/dhcpd "
  start program = "/usr/sbin/rcctl start dhcpd"
  stop program = "/usr/sbin/rcctl stop dhcpd"
  if does not exist for 2 cycles then restart
  if failed uid _dhcp then alert
  if failed euid _dhcp then alert
  if failed gid _dhcp then alert
  depends on GUEST, LAN
{% if iked_enabled %}

check process iked matching "^iked: parent "
  start program = "/usr/sbin/rcctl start iked"
  stop program = "/usr/sbin/rcctl stop iked"
  if does not exist for 2 cycles then restart
  depends on WAN
{% endif %}

check process nginx with pidfile /var/run/nginx.pid
  start program = "/usr/sbin/rcctl start nginx"
  stop program = "/usr/sbin/rcctl stop nginx"
  if does not exist for 2 cycles then restart
# if failed host tombstone.osborn.io port 80 ipv4 proto https request "/ping.txt" status = 307 then alert
# if failed host tombstone.osborn.io port 80 ipv6 proto https request "/ping.txt" status = 307 then alert
  if failed host {{ wan_ipv4|ipaddr('address') }} port 443 ipv4
    proto https
    request "/ping.txt" http headers [Host: {{ ansible_fqdn }}]
    content = "pong"
    then alert
{% if wan_ipv6 is defined %}
  if failed host {{ wan_ipv6|ipaddr('address') }} port 443 ipv6
    proto https
    request "/ping.txt" http headers [Host: {{ ansible_fqdn }}]
    content = "pong"
    then alert
{% endif %}
  depends on WAN

check process nsd with pidfile /var/nsd/run/nsd.pid
  start program = "/usr/sbin/rcctl start nsd"
  stop program = "/usr/sbin/rcctl stop nsd"
  if does not exist for 2 cycles then restart
  if failed uid _nsd then alert
  if failed euid _nsd then alert
  if failed gid _nsd then alert
  if failed
    host {{ wan_ipv4|ipaddr('address') }} port 53 type udp ipv4 proto dns
    for 5 cycles
    then alert
{% if wan_ipv6 is defined %}
  if failed
    host {{ wan_ipv6|ipaddr('address') }} port 53 type udp ipv6 proto dns
    for 5 cycles
    then alert
{% endif %}
  depends on WAN

check process ntpd matching "^/usr/sbin/ntpd "
  start program = "/usr/sbin/rcctl start ntpd" with timeout 300 seconds
  stop program = "/usr/sbin/rcctl stop ntpd"
  if does not exist for 2 cycles then restart
  if failed
    host {{ lan_ipv4|ipaddr('address') }} port 123 type udp proto ntp3
    for 5 cycles
    then alert
{% if lan_ipv6 is defined %}
  if failed
    host {{ lan_ipv6|ipaddr('address') }} port 123 type udp proto ntp3
    for 5 cycles
    then alert
{% endif %}
  depends on LAN, WAN
{% if vpn_client_if is defined %}

check process openvpn.client with pidfile /var/openvpn/client.pid
  #start program = "/bin/sh /etc/netstart {{ vpn_client_if }}"
  depends on WAN
{% endif %}
{% if vpn_server_if is defined %}

check process openvpn.server with pidfile /var/openvpn/server.pid
  #start program = "/bin/sh /etc/netstart {{ vpn_server_if }}"
  depends on WAN
{% endif %}

check process rtadvd matching "^/usr/sbin/rtadvd "
  start program = "/usr/sbin/rcctl start rtadvd"
  stop program = "/usr/sbin/rcctl stop rtadvd"
  if does not exist for 2 cycles then restart
  if failed uid _rtadvd then alert
  if failed euid _rtadvd then alert
  if failed gid _rtadvd then alert
  depends on LAN, dhcpcd

check process slaacd matching "^/sbin/slaacd$"
  start program = "/usr/sbin/rcctl start slaacd"
  stop program = "/usr/sbin/rcctl stop slaacd"
  if does not exist for 2 cycles then restart

check process smtpd matching "^/usr/sbin/smtpd$"
  start program = "/usr/sbin/rcctl start smtpd"
  stop program = "/usr/sbin/rcctl stop smtpd"
  if does not exist for 2 cycles then restart
  if failed
    host 127.0.0.1 port 25 proto smtp
    for 5 cycles
    then alert
  if failed
    host ::1 port 25 proto smtp
    for 5 cycles
    then alert
  depends on WAN
{% if squid_enabled %}

check process squid with pidfile /var/run/squid.pid
  start program = "/usr/sbin/rcctl start squid"
  stop program = "/usr/sbin/rcctl stop squid"
  if does not exist for 2 cycles then restart
  if failed uid _squid then alert
  if failed euid _squid then alert
  if failed gid _squid then alert
  depends on LAN, WAN
{%   if c_icap_pid_file is defined %}
  depends on c_icap
{%   endif %}
{% endif %}

check process sshd with pidfile /var/run/sshd.pid
  start program = "/usr/sbin/rcctl start sshd"
  stop program = "/usr/sbin/rcctl stop sshd"
  if does not exist for 2 cycles then restart
  depends on LAN, WAN

check process syslogd with pidfile /var/run/syslog.pid
  start program = "/usr/sbin/rcctl start syslogd"
  stop program = "/usr/sbin/rcctl stop syslogd"
  if does not exist for 2 cycles then restart

check process unbound with pidfile /var/run/unbound.pid
  start program = "/usr/sbin/rcctl start unbound"
  stop program = "/usr/sbin/rcctl stop unbound"
  if does not exist for 2 cycles then restart
  if failed uid _unbound then alert
  if failed euid _unbound then alert
  if failed gid _unbound then alert
  if failed
    host 127.0.0.1 port 53 type udp proto dns
    for 5 cycles
    then alert
  if failed
    host {{ lan_ipv4|ipaddr('address') }} port 53 ipv4 type udp proto dns
    for 5 cycles
    then alert
  if failed
    host ::1 port 53 type udp proto dns
    for 5 cycles
    then alert
{% if wan_ipv6 is defined %}
  if failed
    host {{ wan_ipv6|ipaddr('address') }} port 53 ipv6 type udp proto dns
    for 5 cycles
    then alert
{% endif %}
  depends on LAN, WAN

## Check filesystem permissions, uid, gid, space and inode usage. Other services,
## such as databases, may depend on this resource and an automatically graceful
## stop may be cascaded to them before the filesystem will become full and data
## lost.
#
#  check filesystem datafs with path /dev/sdb1
#    start program  = "/bin/mount /data"
#    stop program  = "/bin/umount /data"
#    if failed permission 660 then unmonitor
#    if failed uid root then unmonitor
#    if failed gid disk then unmonitor
#    if space usage > 80% for 5 times within 15 cycles then alert
#    if space usage > 99% then stop
#    if inode usage > 30000 then alert
#    if inode usage > 99% then stop
#    group server

check filesystem root with path /dev/sd0a
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem home with path /dev/sd0d
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem tmp with path /dev/sd0e
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem usr with path /dev/sd0f
  if changed fsflags for 5 cycles then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem usr.X11R6 with path /dev/sd0g
  if changed fsflags for 5 cycles then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem usr.local with path /dev/sd0h
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem var with path /dev/sd0i
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

## Check a file's timestamp. In this example, we test if a file is older
## than 15 minutes and assume something is wrong if its not updated. Also,
## if the file size exceed a given limit, execute a script
#
#  check file database with path /data/mydatabase.db
#    if failed permission 700 then alert
#    if failed uid data then alert
#    if failed gid data then alert
#    if timestamp > 15 minutes then alert
#    if size > 100 MB then exec "/my/cleanup/script" as uid dba and gid dba
#
#
## Check directory permission, uid and gid.  An event is triggered if the
## directory does not belong to the user with uid 0 and gid 0.  In addition,
## the permissions have to match the octal description of 755 (see chmod(1)).
#
#  check directory bin with path /bin
#    if failed permission 755 then unmonitor
#    if failed uid 0 then unmonitor
#    if failed gid 0 then unmonitor

check network GUEST with interface {{ guest_if }}
  #start program = "/bin/sh /etc/netstart {{ guest_if }}"
  #if failed link then alert
  #if changed link capacity then alert
  depends on LAN

check network LAN with interface {{ lan_if }}
  #start program = "/bin/sh /etc/netstart {{ lan_if }}"
  #if failed link then alert
  #if changed link capacity then alert

{% if vpn_client_if is defined %}
check network VPN.CLIENT with interface {{ vpn_client_if }}
  #start program = "/bin/sh /etc/netstart {{ vpn_client_if }}"
  if failed link for 5 cycles then alert
  if changed link for 5 cycles then alert

{% endif %}
{% if vpn_server_if is defined %}
check network VPN.SERVER with interface {{ vpn_server_if }}
  #start program = "/bin/sh /etc/netstart {{ vpn_server_if }}"
  if failed link for 5 cycles then alert
  if changed link for 5 cycles then alert

{% endif %}
check network WAN with interface {{ wan_if }}
  #start program = "/bin/sh /etc/netstart {{ wan_if }}"
  if failed link for 5 cycles then alert
  if changed link for 5 cycles then alert
  depends on WAN.DSL

check network WAN.DSL with interface {{ pppoe_pppoedev }}
  #start program = "/bin/sh /etc/netstart {{ pppoe_pppoedev }}"
  if failed link for 5 cycles then alert
  if changed link for 5 cycles then alert

#check network WLAN with interface {{ wlan_if }}
#  #start program = "/bin/sh /etc/netstart {{ wlan_if }}"
#  #if failed link then alert
#  #if changed link capacity then alert

{% if wan_ipv4_dest is defined %}
check host Bottomless with address {{ wan_ipv4_dest }}
  if failed ping for 5 cycles then alert
  depends on WAN

{% endif %}
# include /etc/monit.d/*
