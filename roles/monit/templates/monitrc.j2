set daemon 60 with start delay 60
set idfile /var/.monit.id
set logfile syslog
set statefile /var/.monit.state

set alert nick@{{ global_domain }} not on { instance, action }
set mailserver localhost
set mail-format {
  subject: monit alert -- $EVENT $SERVICE
  message: $EVENT Service $SERVICE

        Date: $DATE
      Action: $ACTION
        Host: $HOST
 Description: $DESCRIPTION
}

#set httpd port 2812 address "{{ lan_ipv6|ipaddr('address') }}"
set httpd port 2812 address "{{ lan_ipv4|ipaddr('address') }}"
    signature disable
    allow {{ monit_username }}:{{ monit_password }} read-only

###############################################################################
## Services
###############################################################################

#check process avahi-daemon with pidfile /run/avahi-daemon/pid
#  start program = "/usr/bin/systemctl start avahi-daemon"
#  stop program = "/usr/bin/systemctl stop avahi-daemon"
#  if does not exist for 2 cycles then restart
#  if failed uid _avahi then alert
#  if failed euid _avahi then alert
#  if failed gid nobody then alert
#  depends on LAN

check process chronyd with pidfile /run/chronyd.pid
  start program = "/usr/bin/systemctl start chronyd" with timeout 300 seconds
  stop program = "/usr/bin/systemctl stop chronyd"
  if does not exist for 2 cycles then restart
  if failed uid chrony then alert
  if failed euid chrony then alert
  if failed gid chrony then alert
  if failed
    host {{ lan_ipv4|ipaddr('address') }} port 123 type udp proto ntp3
    for 5 cycles
    then alert
  if failed
    host {{ lan_ipv6|ipaddr('address') }} port 123 type udp proto ntp3
    for 5 cycles
    then alert
  depends on LAN, WAN

check process dhcpcd with pidfile /run/dhcpcd.pid
  start program = "/usr/bin/systemctl start dhcpcd"
  stop program = "/usr/bin/systemctl stop dhcpcd"
  if does not exist for 2 cycles then restart
  if failed uid root then alert
  if failed euid root then alert
  if failed gid root then alert
  depends on LAN, WAN

check process dhcpd4 with pidfile /run/dhcpd4.pid
  start program = "/usr/bin/systemctl start dhcpd4"
  stop program = "/usr/bin/systemctl stop dhcpd4"
  if does not exist for 2 cycles then restart
  if failed uid dhcp then alert
  if failed euid dhcp then alert
  if failed gid dhcp then alert
  depends on LAN
  # depends on GUEST, LAN

check process nginx with pidfile /run/nginx.pid
  start program = "/usr/bin/systemctl start nginx"
  stop program = "/usr/bin/systemctl stop nginx"
  if does not exist for 2 cycles then restart
  # if failed host tombstone.osborn.io port 80 ipv4 proto https request "/ping.txt" status = 307 then alert
  # if failed host tombstone.osborn.io port 80 ipv6 proto https request "/ping.txt" status = 307 then alert
  if failed host {{ wan_ipv4|ipaddr('address') }} port 443 ipv4
    proto https
    request "/ping.txt" http headers [Host: {{ ansible_fqdn }}]
    content = "pong"
    then alert
  # if failed host {{ wan_ipv6|ipaddr('address') }} port 443 ipv6
  #   proto https
  #   request "/ping.txt" http headers [Host: {{ ansible_fqdn }}]
  #   content = "pong"
  #   then alert
  depends on WAN

check process nsd with pidfile /run/nsd/nsd.pid
  start program = "/usr/bin/systemctl start nsd"
  stop program = "/usr/bin/systemctl stop nsd"
  if does not exist for 2 cycles then restart
  if failed uid nsd then alert
  if failed euid nsd then alert
  if failed gid nsd then alert
  if failed
    host {{ wan_ipv4|ipaddr('address') }} port 53 type udp ipv4 proto dns
    for 5 cycles
    then alert
  if failed
    host {{ wan_ipv6|ipaddr('address') }} port 53 type udp ipv6 proto dns
    for 5 cycles
    then alert
  depends on WAN

check process pppd with pidfile /run/ppp0.pid
  start program = "/usr/bin/systemctl start ppp@zen"
  stop program = "/usr/bin/systemctl stop ppp@zen"
  if does not exist for 2 cycles then restart
  if failed uid root then alert
  if failed euid root then alert
  if failed gid root then alert

check process radvd with pidfile /run/radvd.pid
  start program = "/usr/bin/systemctl start radvd"
  stop program = "/usr/bin/systemctl stop radvd"
  if does not exist for 2 cycles then restart
  if failed uid root then alert
  if failed euid root then alert
  if failed gid root then alert
  depends on LAN

check process smtpd with pidfile /run/smtpd.pid
  start program = "/usr/bin/systemctl start smtpd"
  stop program = "/usr/sbin/rcctl stop smtpd"
  if does not exist for 2 cycles then restart
  if failed
    host 127.0.0.1 port 25 proto smtp
    for 5 cycles
    then alert
  if failed
    host ::1 port 25 proto smtp
    for 5 cycles
    then alert
  depends on WAN

check process sshd with pidfile /run/sshd.pid
  start program = "/usr/bin/systemctl start sshd"
  stop program = "/usr/bin/systemctl stop sshd"
  if does not exist for 2 cycles then restart
  if failed uid root then alert
  if failed euid root then alert
  if failed gid root then alert
  depends on LAN, WAN

check process unbound with pidfile /run/unbound.pid
  start program = "/usr/bin/systemctl start unbound"
  stop program = "/usr/bin/systemctl stop unbound"
  if does not exist for 2 cycles then restart
  if failed uid unbound then alert
  if failed euid unbound then alert
  if failed gid unbound then alert
  if failed
    host 127.0.0.1 port 53 type udp proto dns
    for 5 cycles
    then alert
  if failed
    host {{ lan_ipv4|ipaddr('address') }} port 53 ipv4 type udp proto dns
    for 5 cycles
    then alert
  if failed
    host ::1 port 53 type udp proto dns
    for 5 cycles
    then alert
{% if lan_ipv6 is defined %}
#  if failed
#    host {{ lan_ipv6|ipaddr('address') }} port 53 ipv6 type udp proto dns
#    for 5 cycles
#    then alert
{% endif %}
  depends on LAN, WAN

## Check filesystem permissions, uid, gid, space and inode usage. Other services,
## such as databases, may depend on this resource and an automatically graceful
## stop may be cascaded to them before the filesystem will become full and data
## lost.
#
#  check filesystem datafs with path /dev/sdb1
#    start program  = "/bin/mount /data"
#    stop program  = "/bin/umount /data"
#    if failed permission 660 then unmonitor
#    if failed uid root then unmonitor
#    if failed gid disk then unmonitor
#    if space usage > 80% for 5 times within 15 cycles then alert
#    if space usage > 99% then stop
#    if inode usage > 30000 then alert
#    if inode usage > 99% then stop
#    group server

check filesystem boot with path /dev/sda1
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

check filesystem root with path /dev/sda2
  if changed fsflags then alert
  if space usage > 70% for 5 times within 15 cycles then alert
  if inode usage > 70% for 5 times within 15 cycles then alert

## Check a file's timestamp. In this example, we test if a file is older
## than 15 minutes and assume something is wrong if its not updated. Also,
## if the file size exceed a given limit, execute a script
#
#  check file database with path /data/mydatabase.db
#    if failed permission 700 then alert
#    if failed uid data then alert
#    if failed gid data then alert
#    if timestamp > 15 minutes then alert
#    if size > 100 MB then exec "/my/cleanup/script" as uid dba and gid dba
#
#
## Check directory permission, uid and gid.  An event is triggered if the
## directory does not belong to the user with uid 0 and gid 0.  In addition,
## the permissions have to match the octal description of 755 (see chmod(1)).
#
#  check directory bin with path /bin
#    if failed permission 755 then unmonitor
#    if failed uid 0 then unmonitor
#    if failed gid 0 then unmonitor

check network GUEST with interface {{ guest_if }}
  #start program = "/bin/sh /etc/netstart {{ guest_if }}"
  #if failed link then alert
  #if changed link capacity then alert
  depends on LAN

check network LAN with interface {{ lan_if }}
  #start program = "/bin/sh /etc/netstart {{ lan_if }}"
  #if failed link then alert
  #if changed link capacity then alert

check network WAN with interface {{ wan_if }}
  start program = "/usr/bin/systemctl start ppp@zen"
  if failed link for 5 cycles then alert
  if changed link for 5 cycles then alert
  depends on pppd
# depends on WAN.DSL

#check network WAN.DSL with interface {{ pppoe_pppoedev }}
#  #start program = "/bin/sh /etc/netstart {{ pppoe_pppoedev }}"
#  if failed link for 5 cycles then alert
#  if changed link for 5 cycles then alert

#check network WLAN with interface {{ wlan_if }}
#  #start program = "/bin/sh /etc/netstart {{ wlan_if }}"
#  #if failed link then alert
#  #if changed link capacity then alert

#include /etc/monit.d/*
